import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

public class TimeBased {

    private final static AtomicInteger count = new AtomicInteger(0);

    static long start = System.currentTimeMillis();

    public static void main(String args[]) {
        ExecutorService executor = Executors.newFixedThreadPool(100);

        for (int i = 0; i < 1000000000; i++) {
            if ((System.currentTimeMillis() - start) >= 0)
                System.exit(0);
            Runnable worker = new MultithreadingDemo(); // have a AtomicInteger int to increment the value

            executor.execute(worker);
        }
        executor.shutdown();
        // Wait until all threads are finish
        while (!executor.isTerminated()) {

        }
    }

    static class MultithreadingDemo implements Runnable {

        private static DateFormat dateFormatter;

        private static String dateFormat = "yyyy-MM-dd";

        @Override
        public void run() {
            try {

                // Displaying the thread that is running
                // System.out.println("Thread " + Thread.currentThread().getId() + " is running");
                // DateFormat dateFormatter = null;

                dateFormatter = new SimpleDateFormat(dateFormat);

                // synchronized (dateFormatter) {
                String formattedDate = dateFormatter.format(Calendar.getInstance().getTimeInMillis());
                // }

                count.incrementAndGet();
                // System.out.println(formattedDate);

            } catch (Exception e) {
                // Throwing an exception
                System.out.println("Exception is caught");
            }
            System.out.println("End : " + new Timestamp(Calendar.getInstance().getTimeInMillis()));

        }
    }
}
